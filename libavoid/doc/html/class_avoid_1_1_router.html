<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Avoid::Router Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<style>
pre { 
    border: dotted 1px #900; 
    padding: 5px; 
    background-color: #ffe;
}
a.anchor:hover {
    text-decoration: none;
}
</style>
</head>
<body>
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_avoid.html">Avoid</a></li><li class="navelem"><a class="el" href="class_avoid_1_1_router.html">Router</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_avoid_1_1_router-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Avoid::Router Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="class_avoid_1_1_router.html" title="The Router class represents a libavoid router instance.">Router</a> class represents a libavoid router instance.  
 <a href="class_avoid_1_1_router.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="router_8h_source.html">router.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aae0b300221fbff0d5539ef42e99d8714"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#aae0b300221fbff0d5539ef42e99d8714">Router</a> (const unsigned int flags)</td></tr>
<tr class="memdesc:aae0b300221fbff0d5539ef42e99d8714"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for router instance.  <a href="class_avoid_1_1_router.html#aae0b300221fbff0d5539ef42e99d8714">More...</a><br /></td></tr>
<tr class="separator:aae0b300221fbff0d5539ef42e99d8714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415aa6409ec5d573bcdb90b1ce73e020"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a415aa6409ec5d573bcdb90b1ce73e020">~Router</a> ()</td></tr>
<tr class="memdesc:a415aa6409ec5d573bcdb90b1ce73e020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for router instance.  <a href="class_avoid_1_1_router.html#a415aa6409ec5d573bcdb90b1ce73e020">More...</a><br /></td></tr>
<tr class="separator:a415aa6409ec5d573bcdb90b1ce73e020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b2908173631381499be763ea0b0dad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad">setTransactionUse</a> (const bool transactions)</td></tr>
<tr class="memdesc:a74b2908173631381499be763ea0b0dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows setting of the behaviour of the router in regard to transactions. This controls whether transactions are used to queue changes and process them efficiently at once or they are instead processed immediately.  <a href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad">More...</a><br /></td></tr>
<tr class="separator:a74b2908173631381499be763ea0b0dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd68dedfd16678f236b4f3bc12d17ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#aecd68dedfd16678f236b4f3bc12d17ab">transactionUse</a> (void) const</td></tr>
<tr class="memdesc:aecd68dedfd16678f236b4f3bc12d17ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports whether the router groups actions into transactions.  <a href="class_avoid_1_1_router.html#aecd68dedfd16678f236b4f3bc12d17ab">More...</a><br /></td></tr>
<tr class="separator:aecd68dedfd16678f236b4f3bc12d17ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4497126d8d4c76a122af565260941fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc">processTransaction</a> (void)</td></tr>
<tr class="memdesc:ac4497126d8d4c76a122af565260941fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes the current transaction and processes all the queued object changes efficiently.  <a href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc">More...</a><br /></td></tr>
<tr class="separator:ac4497126d8d4c76a122af565260941fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f91cdcf5dc6ca0ec278e7943f8f21a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a1f91cdcf5dc6ca0ec278e7943f8f21a5">deleteShape</a> (<a class="el" href="class_avoid_1_1_shape_ref.html">ShapeRef</a> *shape)</td></tr>
<tr class="memdesc:a1f91cdcf5dc6ca0ec278e7943f8f21a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a shape from the router scene.  <a href="class_avoid_1_1_router.html#a1f91cdcf5dc6ca0ec278e7943f8f21a5">More...</a><br /></td></tr>
<tr class="separator:a1f91cdcf5dc6ca0ec278e7943f8f21a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766c0dd498c38822cf9ea7c77af28b3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a766c0dd498c38822cf9ea7c77af28b3d">moveShape</a> (<a class="el" href="class_avoid_1_1_shape_ref.html">ShapeRef</a> *shape, const <a class="el" href="class_avoid_1_1_polygon.html">Polygon</a> &amp;newPoly, const bool first_move=false)</td></tr>
<tr class="memdesc:a766c0dd498c38822cf9ea7c77af28b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move or resize an existing shape within the router scene.  <a href="class_avoid_1_1_router.html#a766c0dd498c38822cf9ea7c77af28b3d">More...</a><br /></td></tr>
<tr class="separator:a766c0dd498c38822cf9ea7c77af28b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac171735c187b3e0ea8f03fda4424fd4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#ac171735c187b3e0ea8f03fda4424fd4f">moveShape</a> (<a class="el" href="class_avoid_1_1_shape_ref.html">ShapeRef</a> *shape, const double xDiff, const double yDiff)</td></tr>
<tr class="memdesc:ac171735c187b3e0ea8f03fda4424fd4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move an existing shape within the router scene by a relative distance.  <a href="class_avoid_1_1_router.html#ac171735c187b3e0ea8f03fda4424fd4f">More...</a><br /></td></tr>
<tr class="separator:ac171735c187b3e0ea8f03fda4424fd4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b044531d3dc81fa76819e55917924b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a5b044531d3dc81fa76819e55917924b0">deleteJunction</a> (<a class="el" href="class_avoid_1_1_junction_ref.html">JunctionRef</a> *junction)</td></tr>
<tr class="memdesc:a5b044531d3dc81fa76819e55917924b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a junction from the router scene.  <a href="class_avoid_1_1_router.html#a5b044531d3dc81fa76819e55917924b0">More...</a><br /></td></tr>
<tr class="separator:a5b044531d3dc81fa76819e55917924b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316f15b3e974c273bb55cfb19b751394"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a316f15b3e974c273bb55cfb19b751394">deleteConnector</a> (<a class="el" href="class_avoid_1_1_conn_ref.html">ConnRef</a> *connector)</td></tr>
<tr class="memdesc:a316f15b3e974c273bb55cfb19b751394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a connector from the router scene.  <a href="class_avoid_1_1_router.html#a316f15b3e974c273bb55cfb19b751394">More...</a><br /></td></tr>
<tr class="separator:a316f15b3e974c273bb55cfb19b751394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08021cac275575c7795e2005e5eadb9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a08021cac275575c7795e2005e5eadb9a">moveJunction</a> (<a class="el" href="class_avoid_1_1_junction_ref.html">JunctionRef</a> *junction, const <a class="el" href="class_avoid_1_1_point.html">Point</a> &amp;newPosition)</td></tr>
<tr class="memdesc:a08021cac275575c7795e2005e5eadb9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move an existing junction within the router scene.  <a href="class_avoid_1_1_router.html#a08021cac275575c7795e2005e5eadb9a">More...</a><br /></td></tr>
<tr class="separator:a08021cac275575c7795e2005e5eadb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e5639b590902b5e734a1068fdc663c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a94e5639b590902b5e734a1068fdc663c">moveJunction</a> (<a class="el" href="class_avoid_1_1_junction_ref.html">JunctionRef</a> *junction, const double xDiff, const double yDiff)</td></tr>
<tr class="memdesc:a94e5639b590902b5e734a1068fdc663c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move an existing junction within the router scene by a relative distance.  <a href="class_avoid_1_1_router.html#a94e5639b590902b5e734a1068fdc663c">More...</a><br /></td></tr>
<tr class="separator:a94e5639b590902b5e734a1068fdc663c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596cecf98ff1b40a8ee5c703e175ff62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a596cecf98ff1b40a8ee5c703e175ff62">setRoutingParameter</a> (const <a class="el" href="namespace_avoid.html#a8a0154ae39129e7737d98e5a83daed19">RoutingParameter</a> parameter, const double value=chooseSensibleParamValue)</td></tr>
<tr class="memdesc:a596cecf98ff1b40a8ee5c703e175ff62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets values for routing parameters, including routing penalties.  <a href="class_avoid_1_1_router.html#a596cecf98ff1b40a8ee5c703e175ff62">More...</a><br /></td></tr>
<tr class="separator:a596cecf98ff1b40a8ee5c703e175ff62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08a56fa47c415c0450e20bbb438f420"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#ab08a56fa47c415c0450e20bbb438f420">routingParameter</a> (const <a class="el" href="namespace_avoid.html#a8a0154ae39129e7737d98e5a83daed19">RoutingParameter</a> parameter) const</td></tr>
<tr class="memdesc:ab08a56fa47c415c0450e20bbb438f420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current value for a particular routing parameter of a given type.  <a href="class_avoid_1_1_router.html#ab08a56fa47c415c0450e20bbb438f420">More...</a><br /></td></tr>
<tr class="separator:ab08a56fa47c415c0450e20bbb438f420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f057f6d101f010588c9022893c9ac1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a09f057f6d101f010588c9022893c9ac1">setRoutingOption</a> (const <a class="el" href="namespace_avoid.html#abc707ccbd6a0a7c29c124162c864ca05">RoutingOption</a> option, const bool value)</td></tr>
<tr class="memdesc:a09f057f6d101f010588c9022893c9ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn specific routing options on or off.  <a href="class_avoid_1_1_router.html#a09f057f6d101f010588c9022893c9ac1">More...</a><br /></td></tr>
<tr class="separator:a09f057f6d101f010588c9022893c9ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ee63586c12d0a3518dd5caebcb92d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a24ee63586c12d0a3518dd5caebcb92d2">routingOption</a> (const <a class="el" href="namespace_avoid.html#abc707ccbd6a0a7c29c124162c864ca05">RoutingOption</a> option) const</td></tr>
<tr class="memdesc:a24ee63586c12d0a3518dd5caebcb92d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current state for a specific routing option.  <a href="class_avoid_1_1_router.html#a24ee63586c12d0a3518dd5caebcb92d2">More...</a><br /></td></tr>
<tr class="separator:a24ee63586c12d0a3518dd5caebcb92d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbda0590ff3234faad409e2f39e1c9ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#acbda0590ff3234faad409e2f39e1c9ec">setRoutingPenalty</a> (const <a class="el" href="namespace_avoid.html#a8a0154ae39129e7737d98e5a83daed19">RoutingParameter</a> penType, const double penVal=chooseSensibleParamValue)</td></tr>
<tr class="memdesc:acbda0590ff3234faad409e2f39e1c9ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets or removes penalty values that are applied during connector routing.  <a href="class_avoid_1_1_router.html#acbda0590ff3234faad409e2f39e1c9ec">More...</a><br /></td></tr>
<tr class="separator:acbda0590ff3234faad409e2f39e1c9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc66cd795e86d921da1e8d9cb8a5c21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_avoid_1_1_hyperedge_rerouter.html">HyperedgeRerouter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a3fc66cd795e86d921da1e8d9cb8a5c21">hyperedgeRerouter</a> (void)</td></tr>
<tr class="memdesc:a3fc66cd795e86d921da1e8d9cb8a5c21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the hyperedge rerouter for the router.  <a href="class_avoid_1_1_router.html#a3fc66cd795e86d921da1e8d9cb8a5c21">More...</a><br /></td></tr>
<tr class="separator:a3fc66cd795e86d921da1e8d9cb8a5c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458aae2d6447e0958e4916a8c29bbb47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a458aae2d6447e0958e4916a8c29bbb47">outputInstanceToSVG</a> (std::string filename=std::string())</td></tr>
<tr class="memdesc:a458aae2d6447e0958e4916a8c29bbb47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates an SVG file containing debug output and code that can be used to regenerate the instance.  <a href="class_avoid_1_1_router.html#a458aae2d6447e0958e4916a8c29bbb47">More...</a><br /></td></tr>
<tr class="separator:a458aae2d6447e0958e4916a8c29bbb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202c28fcb04f7af2183fe6849b4ce2f3"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a202c28fcb04f7af2183fe6849b4ce2f3">newObjectId</a> (void) const</td></tr>
<tr class="memdesc:a202c28fcb04f7af2183fe6849b4ce2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the object ID used for automatically generated objects, such as during hyperedge routing.  <a href="class_avoid_1_1_router.html#a202c28fcb04f7af2183fe6849b4ce2f3">More...</a><br /></td></tr>
<tr class="separator:a202c28fcb04f7af2183fe6849b4ce2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f36729c98e13e57d2c56c0d1facf86c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a8f36729c98e13e57d2c56c0d1facf86c">objectIdIsUnused</a> (const unsigned int id) const</td></tr>
<tr class="memdesc:a8f36729c98e13e57d2c56c0d1facf86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the given ID is already used.  <a href="class_avoid_1_1_router.html#a8f36729c98e13e57d2c56c0d1facf86c">More...</a><br /></td></tr>
<tr class="separator:a8f36729c98e13e57d2c56c0d1facf86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebc288933c13b8b8794e11e915a889f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a2ebc288933c13b8b8794e11e915a889f">shouldContinueTransactionWithProgress</a> (unsigned int elapsedTime, unsigned int phaseNumber, unsigned int totalPhases, double proportion)</td></tr>
<tr class="memdesc:a2ebc288933c13b8b8794e11e915a889f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A method called at regular intervals during transaction processing to report progress and ask if the <a class="el" href="class_avoid_1_1_router.html" title="The Router class represents a libavoid router instance.">Router</a> should continue the transaction.  <a href="class_avoid_1_1_router.html#a2ebc288933c13b8b8794e11e915a889f">More...</a><br /></td></tr>
<tr class="separator:a2ebc288933c13b8b8794e11e915a889f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a8a79a5726d9a487864381630a9a90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_avoid_1_1_hyperedge_new_and_deleted_object_lists.html">HyperedgeNewAndDeletedObjectLists</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a20a8a79a5726d9a487864381630a9a90">newAndDeletedObjectListsFromHyperedgeImprovement</a> (void) const</td></tr>
<tr class="memdesc:a20a8a79a5726d9a487864381630a9a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a <a class="el" href="struct_avoid_1_1_hyperedge_new_and_deleted_object_lists.html" title="The HyperedgeNewAndDeletedObjectLists class stores lists of objects created and deleted during hypere...">HyperedgeNewAndDeletedObjectLists</a> detailing the lists of junctions and connectors created and deleted during hyperedge improvement.  <a href="class_avoid_1_1_router.html#a20a8a79a5726d9a487864381630a9a90">More...</a><br /></td></tr>
<tr class="separator:a20a8a79a5726d9a487864381630a9a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d18149edbd47373a63c799c1c71bfa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_router.html#a2d18149edbd47373a63c799c1c71bfa4">setTopologyAddon</a> (TopologyAddonInterface *topologyAddon)</td></tr>
<tr class="memdesc:a2d18149edbd47373a63c799c1c71bfa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an addon for doing orthogonal topology improvement.  <a href="class_avoid_1_1_router.html#a2d18149edbd47373a63c799c1c71bfa4">More...</a><br /></td></tr>
<tr class="separator:a2d18149edbd47373a63c799c1c71bfa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="class_avoid_1_1_router.html" title="The Router class represents a libavoid router instance.">Router</a> class represents a libavoid router instance. </p>
<p>Usually you would keep a separate <a class="el" href="class_avoid_1_1_router.html" title="The Router class represents a libavoid router instance.">Router</a> instance for each diagram or layout you have open in your application. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aae0b300221fbff0d5539ef42e99d8714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0b300221fbff0d5539ef42e99d8714">&#9670;&nbsp;</a></span>Router()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Avoid::Router::Router </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for router instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>One or more <a class="el" href="namespace_avoid.html#a8b398574e5b64951b7f23a36a1cdfcf4" title="Flags that can be passed to the router during initialisation to specify options.">Avoid::RouterFlag</a> options to control the behaviour of the router. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a415aa6409ec5d573bcdb90b1ce73e020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415aa6409ec5d573bcdb90b1ce73e020">&#9670;&nbsp;</a></span>~Router()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Avoid::Router::~Router </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor for router instance. </p>
<dl class="section note"><dt>Note</dt><dd>Destroying a router instance will delete all remaining shapes and connectors, thereby invalidating any existing pointers to them. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a316f15b3e974c273bb55cfb19b751394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316f15b3e974c273bb55cfb19b751394">&#9670;&nbsp;</a></span>deleteConnector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::deleteConnector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_conn_ref.html">ConnRef</a> *&#160;</td>
          <td class="paramname"><em>connector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a connector from the router scene. </p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<p>You should not use the connector reference again after this call. The router will handle freeing of the connector's memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">connector</td><td>Pointer reference to the connector being removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b044531d3dc81fa76819e55917924b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b044531d3dc81fa76819e55917924b0">&#9670;&nbsp;</a></span>deleteJunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::deleteJunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_junction_ref.html">JunctionRef</a> *&#160;</td>
          <td class="paramname"><em>junction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a junction from the router scene. </p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<p>You should not use the junction reference again after this call. The router will handle freeing of the junction's memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">junction</td><td>Pointer reference to the junction being removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f91cdcf5dc6ca0ec278e7943f8f21a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f91cdcf5dc6ca0ec278e7943f8f21a5">&#9670;&nbsp;</a></span>deleteShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::deleteShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_shape_ref.html">ShapeRef</a> *&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a shape from the router scene. </p>
<p>Connectors that could have a better (usually shorter) path after the removal of this shape will be marked as needing to be rerouted.</p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<p>You should not use the shape reference again after this call. The router will handle freeing of the shape's memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>Pointer reference to the shape being removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3fc66cd795e86d921da1e8d9cb8a5c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fc66cd795e86d921da1e8d9cb8a5c21">&#9670;&nbsp;</a></span>hyperedgeRerouter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_avoid_1_1_hyperedge_rerouter.html">HyperedgeRerouter</a> * Avoid::Router::hyperedgeRerouter </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the hyperedge rerouter for the router. </p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="class_avoid_1_1_hyperedge_rerouter.html" title="The HyperedgeRerouter class is a convenience object that can be used to register hyperedges to be rer...">HyperedgeRerouter</a> object that can be used to register hyperedges for rerouting. </dd></dl>

</div>
</div>
<a id="a94e5639b590902b5e734a1068fdc663c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e5639b590902b5e734a1068fdc663c">&#9670;&nbsp;</a></span>moveJunction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::moveJunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_junction_ref.html">JunctionRef</a> *&#160;</td>
          <td class="paramname"><em>junction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>xDiff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>yDiff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move an existing junction within the router scene by a relative distance. </p>
<p>Connectors that are attached to this junction will be rerouted as a result of the move.</p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">junction</td><td>Pointer reference to the junction being moved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xDiff</td><td>The distance to move the junction in the x dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yDiff</td><td>The distance to move the junction in the y dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08021cac275575c7795e2005e5eadb9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08021cac275575c7795e2005e5eadb9a">&#9670;&nbsp;</a></span>moveJunction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::moveJunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_junction_ref.html">JunctionRef</a> *&#160;</td>
          <td class="paramname"><em>junction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_avoid_1_1_point.html">Point</a> &amp;&#160;</td>
          <td class="paramname"><em>newPosition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move an existing junction within the router scene. </p>
<p>Connectors that are attached to this junction will be rerouted as a result of the move.</p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">junction</td><td>Pointer reference to the junction being moved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newPosition</td><td>The new position for the junction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac171735c187b3e0ea8f03fda4424fd4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac171735c187b3e0ea8f03fda4424fd4f">&#9670;&nbsp;</a></span>moveShape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::moveShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_shape_ref.html">ShapeRef</a> *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>xDiff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>yDiff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move an existing shape within the router scene by a relative distance. </p>
<p>Connectors that intersect the shape's new position, or that could have a better (usually shorter) path after the change, will be marked as needing to be rerouted.</p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>Pointer reference to the shape being moved. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">xDiff</td><td>The distance to move the shape in the x dimension. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">yDiff</td><td>The distance to move the shape in the y dimension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a766c0dd498c38822cf9ea7c77af28b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a766c0dd498c38822cf9ea7c77af28b3d">&#9670;&nbsp;</a></span>moveShape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::moveShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_shape_ref.html">ShapeRef</a> *&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_avoid_1_1_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>newPoly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>first_move</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move or resize an existing shape within the router scene. </p>
<p>A new polygon for the shape can be given to effectively move or resize the shape with the scene. Connectors that intersect the new shape polygon, or that could have a better (usually shorter) path after the change, will be marked as needing to be rerouted.</p>
<p>If the router is using transactions, then this action will occur the next time <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">Router::processTransaction()</a> is called. See <a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">Router::setTransactionUse()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">shape</td><td>Pointer reference to the shape being moved/resized. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newPoly</td><td>The new polygon boundary for the shape. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first_move</td><td>This option is used for some advanced (currently undocumented) behaviour and it should be ignored for the moment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20a8a79a5726d9a487864381630a9a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20a8a79a5726d9a487864381630a9a90">&#9670;&nbsp;</a></span>newAndDeletedObjectListsFromHyperedgeImprovement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_avoid_1_1_hyperedge_new_and_deleted_object_lists.html">HyperedgeNewAndDeletedObjectLists</a> Avoid::Router::newAndDeletedObjectListsFromHyperedgeImprovement </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a <a class="el" href="struct_avoid_1_1_hyperedge_new_and_deleted_object_lists.html" title="The HyperedgeNewAndDeletedObjectLists class stores lists of objects created and deleted during hypere...">HyperedgeNewAndDeletedObjectLists</a> detailing the lists of junctions and connectors created and deleted during hyperedge improvement. </p>
<p>This method will only return information once the router has processed the transaction. You should read and act on this information before <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">processTransaction()</a> is called again.</p>
<p>After calling this you should no longer refer to any of the objects in the "deleted" lists &mdash; the router will delete these and free their memory at its convenience.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="struct_avoid_1_1_hyperedge_new_and_deleted_object_lists.html" title="The HyperedgeNewAndDeletedObjectLists class stores lists of objects created and deleted during hypere...">HyperedgeNewAndDeletedObjectLists</a> containing lists of junctions and connectors created and deleted. </dd></dl>

</div>
</div>
<a id="a202c28fcb04f7af2183fe6849b4ce2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a202c28fcb04f7af2183fe6849b4ce2f3">&#9670;&nbsp;</a></span>newObjectId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Avoid::Router::newObjectId </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the object ID used for automatically generated objects, such as during hyperedge routing. </p>
<p>Reimplement this in a subclass to set specific IDs for new objects.</p>
<dl class="section note"><dt>Note</dt><dd>Your implementation should return a value that does not fail <a class="el" href="class_avoid_1_1_router.html#a8f36729c98e13e57d2c56c0d1facf86c" title="Returns whether or not the given ID is already used.">objectIdIsUnused()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The ID for a new object. </dd></dl>

</div>
</div>
<a id="a8f36729c98e13e57d2c56c0d1facf86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f36729c98e13e57d2c56c0d1facf86c">&#9670;&nbsp;</a></span>objectIdIsUnused()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Avoid::Router::objectIdIsUnused </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether or not the given ID is already used. </p>
<p>You should only need this if you reimplement <a class="el" href="class_avoid_1_1_router.html#a202c28fcb04f7af2183fe6849b4ce2f3" title="Returns the object ID used for automatically generated objects, such as during hyperedge routing.">newObjectId()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>An ID to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean denoting that the given ID is unused. </dd></dl>

</div>
</div>
<a id="a458aae2d6447e0958e4916a8c29bbb47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a458aae2d6447e0958e4916a8c29bbb47">&#9670;&nbsp;</a></span>outputInstanceToSVG()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::outputInstanceToSVG </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em> = <code>std::string()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates an SVG file containing debug output and code that can be used to regenerate the instance. </p>
<p>If transactions are being used, then this method should be called after <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">processTransaction()</a> has been called, so that it includes any changes being queued by the router.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>A string indicating the filename (without extension) for the output file. Defaults to "libavoid-debug.svg" if no filename is given. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4497126d8d4c76a122af565260941fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4497126d8d4c76a122af565260941fc">&#9670;&nbsp;</a></span>processTransaction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Avoid::Router::processTransaction </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes the current transaction and processes all the queued object changes efficiently. </p>
<p>This method will efficiently process all moves, additions and deletions that have occurred since <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">processTransaction()</a> was last called.</p>
<p>If <a class="el" href="class_avoid_1_1_router.html#aecd68dedfd16678f236b4f3bc12d17ab" title="Reports whether the router groups actions into transactions.">transactionUse()</a> is false, then all actions will have been processed immediately and this method will do nothing.</p>
<dl class="section return"><dt>Returns</dt><dd>A boolean value describing whether there were any actions to process.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">setTransactionUse</a> </dd></dl>

</div>
</div>
<a id="a24ee63586c12d0a3518dd5caebcb92d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ee63586c12d0a3518dd5caebcb92d2">&#9670;&nbsp;</a></span>routingOption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Avoid::Router::routingOption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_avoid.html#abc707ccbd6a0a7c29c124162c864ca05">RoutingOption</a>&#160;</td>
          <td class="paramname"><em>option</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current state for a specific routing option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>The type of routing option, a RoutingOption. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boolean representing the option state. </dd></dl>

</div>
</div>
<a id="ab08a56fa47c415c0450e20bbb438f420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08a56fa47c415c0450e20bbb438f420">&#9670;&nbsp;</a></span>routingParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Avoid::Router::routingParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_avoid.html#a8a0154ae39129e7737d98e5a83daed19">RoutingParameter</a>&#160;</td>
          <td class="paramname"><em>parameter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current value for a particular routing parameter of a given type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter</td><td>The type of parameter, a RoutingParameter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value for the specified routing parameter. </dd></dl>

</div>
</div>
<a id="a09f057f6d101f010588c9022893c9ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f057f6d101f010588c9022893c9ac1">&#9670;&nbsp;</a></span>setRoutingOption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::setRoutingOption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_avoid.html#abc707ccbd6a0a7c29c124162c864ca05">RoutingOption</a>&#160;</td>
          <td class="paramname"><em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turn specific routing options on or off. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">option</td><td>The type of routing option, a RoutingOption. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>A boolean representing the option state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a596cecf98ff1b40a8ee5c703e175ff62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a596cecf98ff1b40a8ee5c703e175ff62">&#9670;&nbsp;</a></span>setRoutingParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::setRoutingParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_avoid.html#a8a0154ae39129e7737d98e5a83daed19">RoutingParameter</a>&#160;</td>
          <td class="paramname"><em>parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>value</em> = <code>chooseSensibleParamValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets values for routing parameters, including routing penalties. </p>
<p>libavoid uses a set of parameters to allow the user more control over routing style and quality. These different parameters are described and explained by the RoutingParameter enum. All parameters have sensible defaults.</p>
<p>Regarding routing penalties, libavoid will by default produce shortest path routes between the source and destination points for each connector. There are several penalties that can be applied during this stage to penalise certain conditions and thus improve the aesthetics of the routes generated. <br  />
</p>
<p>If a value of zero or Avoid::zeroParamValue is given then the particular parameter value or penalty will be removed. If no parameter value argument (or a negative value) is specified when calling this method, then a sensible penalty value will be automatically chosen.</p>
<p>This method does not re-trigger processing of connectors. The new parameter value will be used the next time rerouting is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parameter</td><td>The type of penalty, a RoutingParameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be set for that parameter. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbda0590ff3234faad409e2f39e1c9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbda0590ff3234faad409e2f39e1c9ec">&#9670;&nbsp;</a></span>setRoutingPenalty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::setRoutingPenalty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_avoid.html#a8a0154ae39129e7737d98e5a83daed19">RoutingParameter</a>&#160;</td>
          <td class="paramname"><em>penType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>penVal</em> = <code>chooseSensibleParamValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets or removes penalty values that are applied during connector routing. </p>
<dl class="section note"><dt>Note</dt><dd>This is a convenience wrapper for the <a class="el" href="class_avoid_1_1_router.html#a596cecf98ff1b40a8ee5c703e175ff62" title="Sets values for routing parameters, including routing penalties.">setRoutingParameter()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">penType</td><td>The type of penalty, a RoutingParameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">penVal</td><td>The value to be applied for each occurrence of the penalty case. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d18149edbd47373a63c799c1c71bfa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d18149edbd47373a63c799c1c71bfa4">&#9670;&nbsp;</a></span>setTopologyAddon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::setTopologyAddon </td>
          <td>(</td>
          <td class="paramtype">TopologyAddonInterface *&#160;</td>
          <td class="paramname"><em>topologyAddon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an addon for doing orthogonal topology improvement. </p>
<p>It is expected that you would use the topology::AvoidTopologyAddon() from libtopology rather than write your own. This is done so that libavoid does not have to depend on libtopology. </p>

</div>
</div>
<a id="a74b2908173631381499be763ea0b0dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b2908173631381499be763ea0b0dad">&#9670;&nbsp;</a></span>setTransactionUse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::Router::setTransactionUse </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transactions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows setting of the behaviour of the router in regard to transactions. This controls whether transactions are used to queue changes and process them efficiently at once or they are instead processed immediately. </p>
<p>It is more efficient to perform actions like shape movement, addition or deletion as batch tasks, and reroute the necessary connectors just once after these actions have been performed. For this reason, libavoid allows you to group such actions into "transactions" that are processed efficiently when the <a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">processTransaction()</a> method is called.</p>
<p>By default, the router will process all actions as transactions. If <a class="el" href="class_avoid_1_1_router.html#aecd68dedfd16678f236b4f3bc12d17ab" title="Reports whether the router groups actions into transactions.">transactionUse()</a> is set to false, then all actions will get processed immediately, and cause immediate routing callbacks to all affected connectors after each action.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transactions</td><td>A boolean value specifying whether to use transactions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ebc288933c13b8b8794e11e915a889f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebc288933c13b8b8794e11e915a889f">&#9670;&nbsp;</a></span>shouldContinueTransactionWithProgress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Avoid::Router::shouldContinueTransactionWithProgress </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>elapsedTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>phaseNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>totalPhases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>proportion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A method called at regular intervals during transaction processing to report progress and ask if the <a class="el" href="class_avoid_1_1_router.html" title="The Router class represents a libavoid router instance.">Router</a> should continue the transaction. </p>
<p>You can subclass the <a class="el" href="class_avoid_1_1_router.html" title="The Router class represents a libavoid router instance.">Avoid::Router</a> class to implement your own behaviour, such as to show a progress bar or cancel the transaction at the user's request.</p>
<p>Note that you can get a sense of progress by looking at the phaseNumber divided by the totalPhases and the progress in the current phase, but be aware that phases and the intervals and proportions at which this method is called will vary, sometime unpredictably.</p>
<p>You can return false to request that the <a class="el" href="class_avoid_1_1_router.html" title="The Router class represents a libavoid router instance.">Router</a> abort the current transaction. Be aware that it may not abort in some phases. For others it may need to clean up some state before it is safe for you to interact with it again. Hence you should wait for a final call to this method with the phase <a class="el" href="namespace_avoid.html#a399b5bb139fe211539f86543bae26900ac71dd55249bb26f39432aeea8dceb281" title="Not a real phase, but represents the router is finished (or has aborted) the transaction and you may ...">Avoid::TransactionPhaseCompleted</a> before continuing.</p>
<dl class="section note"><dt>Note</dt><dd>Your implementation of this method should be very fast as it will be called many times. Also, you should not change or interact with the <a class="el" href="class_avoid_1_1_router.html" title="The Router class represents a libavoid router instance.">Router</a> instance at all during these calls. Wait till you have received a call with the <a class="el" href="namespace_avoid.html#a399b5bb139fe211539f86543bae26900ac71dd55249bb26f39432aeea8dceb281" title="Not a real phase, but represents the router is finished (or has aborted) the transaction and you may ...">Avoid::TransactionPhaseCompleted</a> phase.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elapsedTime</td><td>The number of msec spent on the transaction since it began. </td></tr>
    <tr><td class="paramname">phaseNumber</td><td>A Router::TransactionPhases representing the current phase of the transaction. </td></tr>
    <tr><td class="paramname">totalPhases</td><td>The total number of phases to be performed during the transaction. </td></tr>
    <tr><td class="paramname">proportion</td><td>A double representing the progress in the current phase. Value will be between 0&ndash;1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the router should continue the transaction. This is true in the default (empty) implementation. </dd></dl>

</div>
</div>
<a id="aecd68dedfd16678f236b4f3bc12d17ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd68dedfd16678f236b4f3bc12d17ab">&#9670;&nbsp;</a></span>transactionUse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Avoid::Router::transactionUse </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports whether the router groups actions into transactions. </p>
<dl class="section return"><dt>Returns</dt><dd>A boolean value describing whether transactions are in use.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_avoid_1_1_router.html#a74b2908173631381499be763ea0b0dad" title="Allows setting of the behaviour of the router in regard to transactions. This controls whether transa...">setTransactionUse</a> </dd>
<dd>
<a class="el" href="class_avoid_1_1_router.html#ac4497126d8d4c76a122af565260941fc" title="Finishes the current transaction and processes all the queued object changes efficiently.">processTransaction</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="router_8h_source.html">router.h</a></li>
<li>router.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Oct 16 2022 11:28:31 for libavoid by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
