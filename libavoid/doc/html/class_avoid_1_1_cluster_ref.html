<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Avoid::ClusterRef Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<style>
pre { 
    border: dotted 1px #900; 
    padding: 5px; 
    background-color: #ffe;
}
a.anchor:hover {
    text-decoration: none;
}
</style>
</head>
<body>
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_avoid.html">Avoid</a></li><li class="navelem"><a class="el" href="class_avoid_1_1_cluster_ref.html">ClusterRef</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_avoid_1_1_cluster_ref-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Avoid::ClusterRef Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="class_avoid_1_1_cluster_ref.html" title="The ClusterRef class represents a cluster object.">ClusterRef</a> class represents a cluster object.  
 <a href="class_avoid_1_1_cluster_ref.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="viscluster_8h_source.html">viscluster.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9bf803c42a2296fe13ac0fd43d435cd5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_cluster_ref.html#a9bf803c42a2296fe13ac0fd43d435cd5">ClusterRef</a> (<a class="el" href="class_avoid_1_1_router.html">Router</a> *<a class="el" href="class_avoid_1_1_cluster_ref.html#a71039f677ccc38feffd46ab73825cd87">router</a>, <a class="el" href="class_avoid_1_1_polygon.html">Polygon</a> &amp;poly, const unsigned int <a class="el" href="class_avoid_1_1_cluster_ref.html#a7a25b0c34cdad039906693265a9caac8">id</a>=0)</td></tr>
<tr class="memdesc:a9bf803c42a2296fe13ac0fd43d435cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cluster reference constructor.  <a href="class_avoid_1_1_cluster_ref.html#a9bf803c42a2296fe13ac0fd43d435cd5">More...</a><br /></td></tr>
<tr class="separator:a9bf803c42a2296fe13ac0fd43d435cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1114f92b3f18803642ffb9f6564a999d"><td class="memItemLeft" align="right" valign="top"><a id="a1114f92b3f18803642ffb9f6564a999d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_cluster_ref.html#a1114f92b3f18803642ffb9f6564a999d">~ClusterRef</a> ()</td></tr>
<tr class="memdesc:a1114f92b3f18803642ffb9f6564a999d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cluster reference destructor. <br /></td></tr>
<tr class="separator:a1114f92b3f18803642ffb9f6564a999d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bdf3a48e06ae25ae25121e781522f5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_cluster_ref.html#a8bdf3a48e06ae25ae25121e781522f5f">setNewPoly</a> (<a class="el" href="class_avoid_1_1_polygon.html">Polygon</a> &amp;poly)</td></tr>
<tr class="memdesc:a8bdf3a48e06ae25ae25121e781522f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the polygon boundary for this cluster.  <a href="class_avoid_1_1_cluster_ref.html#a8bdf3a48e06ae25ae25121e781522f5f">More...</a><br /></td></tr>
<tr class="separator:a8bdf3a48e06ae25ae25121e781522f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a25b0c34cdad039906693265a9caac8"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_cluster_ref.html#a7a25b0c34cdad039906693265a9caac8">id</a> (void) const</td></tr>
<tr class="memdesc:a7a25b0c34cdad039906693265a9caac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the ID of this cluster.  <a href="class_avoid_1_1_cluster_ref.html#a7a25b0c34cdad039906693265a9caac8">More...</a><br /></td></tr>
<tr class="separator:a7a25b0c34cdad039906693265a9caac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1fa20b079253d53d27abf50d2a8933"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_avoid_1_1_referencing_polygon.html">ReferencingPolygon</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_cluster_ref.html#acd1fa20b079253d53d27abf50d2a8933">polygon</a> (void)</td></tr>
<tr class="memdesc:acd1fa20b079253d53d27abf50d2a8933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the polygon boundary of this cluster.  <a href="class_avoid_1_1_cluster_ref.html#acd1fa20b079253d53d27abf50d2a8933">More...</a><br /></td></tr>
<tr class="separator:acd1fa20b079253d53d27abf50d2a8933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7877b59ea4cb2939047f785382f8008"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_avoid_1_1_polygon.html">Polygon</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_cluster_ref.html#af7877b59ea4cb2939047f785382f8008">rectangularPolygon</a> (void)</td></tr>
<tr class="memdesc:af7877b59ea4cb2939047f785382f8008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the rectangular boundary of this cluster.  <a href="class_avoid_1_1_cluster_ref.html#af7877b59ea4cb2939047f785382f8008">More...</a><br /></td></tr>
<tr class="separator:af7877b59ea4cb2939047f785382f8008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71039f677ccc38feffd46ab73825cd87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_avoid_1_1_router.html">Router</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_avoid_1_1_cluster_ref.html#a71039f677ccc38feffd46ab73825cd87">router</a> (void) const</td></tr>
<tr class="memdesc:a71039f677ccc38feffd46ab73825cd87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the router scene this cluster is in.  <a href="class_avoid_1_1_cluster_ref.html#a71039f677ccc38feffd46ab73825cd87">More...</a><br /></td></tr>
<tr class="separator:a71039f677ccc38feffd46ab73825cd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="class_avoid_1_1_cluster_ref.html" title="The ClusterRef class represents a cluster object.">ClusterRef</a> class represents a cluster object. </p>
<p>Cluster are boundaries around groups of shape objects. Ideally, only connectors with one endpoint inside the cluster and one endpoint outside the cluster will cross the cluster boundary. Connectors that begin and end inside a cluster will not route outside it, and connectors that begin and end outside the cluster will not enter the cluster.</p>
<dl class="section note"><dt>Note</dt><dd>While the functionality of this class works, it is currently experimental you will likely suffer a large performance hit when using it. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9bf803c42a2296fe13ac0fd43d435cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf803c42a2296fe13ac0fd43d435cd5">&#9670;&nbsp;</a></span>ClusterRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Avoid::ClusterRef::ClusterRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_router.html">Router</a> *&#160;</td>
          <td class="paramname"><em>router</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>id</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cluster reference constructor. </p>
<p>Creates a cluster object reference, but does not yet place it into the <a class="el" href="class_avoid_1_1_router.html" title="The Router class represents a libavoid router instance.">Router</a> scene. You can add or remove the cluster to/from the scene with Router::addCluster() and Router::delCluster(). The cluster can effectively be moved with <a class="el" href="class_avoid_1_1_cluster_ref.html#a8bdf3a48e06ae25ae25121e781522f5f" title="Update the polygon boundary for this cluster.">ClusterRef::setNewPoly()</a> method.</p>
<p>The poly argument should be used to specify a polygon boundary. The rectangular boundary will be automatically generated from this. The polygon boundary could be a convex hull consisting of points from the boundaries of shapes.</p>
<dl class="section note"><dt>Note</dt><dd>Regarding IDs: You can let libavoid manually handle IDs by not specifying them. Alternatively, you can specify all IDs yourself, but you must be careful to makes sure that each object in the scene (shape, connector, cluster, etc) is given a unique, positive ID. This uniqueness is checked if assertions are enabled, but if not and there are clashes then strange things can happen.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">router</td><td>The router scene to place the cluster into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">poly</td><td>A <a class="el" href="class_avoid_1_1_polygon.html" title="A dynamic Polygon, to which points can be easily added and removed.">Polygon</a> representing the boundary of the cluster. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>Optionally, a positive integer ID unique among all objects. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7a25b0c34cdad039906693265a9caac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a25b0c34cdad039906693265a9caac8">&#9670;&nbsp;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int Avoid::ClusterRef::id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the ID of this cluster. </p>
<dl class="section return"><dt>Returns</dt><dd>The ID of the cluster. <br  />
 </dd></dl>

</div>
</div>
<a id="acd1fa20b079253d53d27abf50d2a8933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1fa20b079253d53d27abf50d2a8933">&#9670;&nbsp;</a></span>polygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_avoid_1_1_referencing_polygon.html">ReferencingPolygon</a> &amp; Avoid::ClusterRef::polygon </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the polygon boundary of this cluster. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the polygon boundary of the cluster. </dd></dl>

</div>
</div>
<a id="af7877b59ea4cb2939047f785382f8008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7877b59ea4cb2939047f785382f8008">&#9670;&nbsp;</a></span>rectangularPolygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_avoid_1_1_polygon.html">Polygon</a> &amp; Avoid::ClusterRef::rectangularPolygon </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to the rectangular boundary of this cluster. </p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the rectangular boundary of the cluster. </dd></dl>

</div>
</div>
<a id="a71039f677ccc38feffd46ab73825cd87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71039f677ccc38feffd46ab73825cd87">&#9670;&nbsp;</a></span>router()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_avoid_1_1_router.html">Router</a> * Avoid::ClusterRef::router </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the router scene this cluster is in. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the router scene for this cluster. </dd></dl>

</div>
</div>
<a id="a8bdf3a48e06ae25ae25121e781522f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bdf3a48e06ae25ae25121e781522f5f">&#9670;&nbsp;</a></span>setNewPoly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Avoid::ClusterRef::setNewPoly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_avoid_1_1_polygon.html">Polygon</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the polygon boundary for this cluster. </p>
<p>You should specify a polygon boundary. The rectangular one will be generated automatically from this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poly</td><td>A <a class="el" href="class_avoid_1_1_polygon.html" title="A dynamic Polygon, to which points can be easily added and removed.">Polygon</a> representing the boundary of the cluster. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="viscluster_8h_source.html">viscluster.h</a></li>
<li>viscluster.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Oct 16 2022 11:28:31 for libavoid by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
